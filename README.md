# Calc Service: Итоговый проект по годовому курсу Яндекс Лицея "Программирование на Go" | 24 
 #### Проверяющему, 
##### Если при проверке решения, найдете недочет или серьезную ошибку, пожалуйста сообщите мне в `Issues` на github, или в телеграм `@artrubadur`, чтобы я мог их исправить. Я надеюсь на ваше снисхождение и понимание.
## Описание

Calc Service - это распределенная система, предназначенная для вычисления сложных математических выражений. Она состоит из следующих компонентов:

*   **Orchestrator:** Координирует процесс вычисления, разбивая сложные выражения на простые задачи и распределяя их между агентами.
*   **Agent:** Выполняет отдельные математические задачи, полученные от оркестратора, и возвращает результаты.

## Архитектура
```
calc_2/
├───agent
│   ├───cmd
│   └───internal
│       └───workers
├───config
│   └───configs
├───orchestrator
│   ├───cmd
│   └───internal
│       ├───grpcservice
│       ├───handlers
│       ├───managers
│       ├───middlewares
│       ├───providers
│       ├───repositories
│       │   ├───expressions_repository
│       │   ├───session_repository
│       │   ├───tasks_repository
│       │   └───user_repository
│       ├───router
│       └───task_splitter
└───pkg
    ├───database
    ├───initializer
    ├───jwt_manager
    ├───logger
    ├───models
    ├───operators
    ├───proto
    └───shutdown
```

## Конфигурация

### Создание конфигурации
Основные параметры конфигурации находятся в файле `config/configs/<name>.yml`.
При установке проекта будут уже доступны 2 варианта запуска: dev и prod.
Вы можете создать свой файл конфигурации в этой же папке.
Выбрать файл конфигурации можно переменной окружения APP_CFG (`APP_CFG=config/configs/dev.yml`, разрешены расширения `yaml` и `yml`). Если указать значение `CFG_FALSE` файл конфигурации не будет применен.
Вы можете изменить её в файле `.env`. 
В зависимости от терминала вы можете перезаписать её следующим образом:

(только для текущей сессии командной строки)
```shell
$env:APP_CFG="<name>"
```
```bash
set APP_CFG="<name>"
```

Или указать при запуске (Docker):
```bash
docker run -e APP_CFG=<путь> -p 8081:8081 web:latest
```
### Что делают параметры ENV?
```bash
APP_CFG=config/configs/dev.yml // Адрес файла конфигурации, можеть быть CFG_FALSE

SECRET_KEY=secret // Секретный ключ для генерации JWT токенов
TOKEN_TTL_MIN=10 // Время жизни JWT токена
SESSION_CLEAR_MIN=1 // Интервал очисток истекших сессий

DATABASE=calc.db // Путь к базе данных
ORCHESTRATOR_ADDR=127.0.0.1 // Адрес оркестратора
ORCHESTRATOR_HTTP_PORT=8080 // Порт HTTP сервера оркестратора
ORCHESTRATOR_GRPC_PORT=50051 // Порт gRPC сервера оркестратора

AGENT_REPEAT=2000 // Интервал между запросами агента
AGENT_REPEAT_ERR=5000 // Интервал между запросами агента в случае ошибки
COMPUTING_POWER=1 // Количество воркеров агента

// Время выполнения математических операций
TIME_ADDITION_MS=0 // Сложение
TIME_SUBTRACTION_MS=0 // Вычитание
TIME_MULTIPLICATION_MS=0 // Умножение
TIME_DIVISION_MS=0 // Деление
TIME_UNARY_MINUS_MS=0 // Унарный минус
TIME_POWER_MS=0 // Возведение в степень
```
### Что делают параметры файла конфигурации yml?
```yml
services:
  orchestrator:
    # Аналогично ENV
    ORCHESTRATOR_ADDR: '127.0.0.1'
    ORCHESTRATOR_HTTP_PORT: 8080
    ORCHESTRATOR_GRPC_PORT: 50051
    DATABASE: 'calc.db'
  agent:
    # Аналогично ENV
    COMPUTING_POWER: 1
    AGENT_REPEAT: 5000
    AGENT_REPEAT_ERR: 2000

math:
  # Аналогично ENV
  TIME_ADDITION_MS: 0
  # ...

middleware:
  TOKEN_TTL_MIN: 60
  SESSION_CLEAR_MIN: 2
  SECRET_KEY: 'secret'
  cors_allow_origin: # Список разрешенных ориджинов
    - '*'

logger:
  # Параметры логирования. Подробнее в главе "Логгирование"
  level: 1 
  time_format: '2006-01-02 15:04:05'
  call_depth: 2
  disable_call: false
  disable_time: false
  disable_color: false
```

### Процесс применения конфигурации приложением
1. Создается конфигурация по умолчанию
2. Файл по адресу `APP_CFG` из переменной среды перезаписывает все поля если они в нем указаны (иначе пропускает)
  Если `APP_CFG="CFG_FALSE"` то он пропустит этот этап. Если `APP_CFG` пуст или отсутствует то он применит `config/configs/dev.yml`.
3. Поля из .env перезаписывают соответствующие поля в конфигурации если существуют (даже если они указаны в yml)


Вы можете настроить:
*   Адресы и порты для сервисов.
*   Параметры логирования (уровень, формат и т.д.).
*   Время выполнения операций
*   Количество рабочих
*   Интервалы запросов
*   Ключ генерации токенов
*   CORS 
*   Другие параметры, специфичные для каждого сервиса.

Приложение сможет запуститься при ошибках на 2 и 3 пунктах (переменные среды или файл yml отсутствуют), используя конфигурацию по умолчанию.

## Сборка и запуск

### Сборка:

### Сборка (без Docker):

1.  Клонируйте репозиторий:

    ```bash
    git clone https://github.com/OinkiePie/calc_3
    ```
    ```bash
    cd calc_3
    ```

2.  Соберите исполняемые файлы для каждого сервиса:

    ```bash
    go build -o build/agent.exe ./agent/cmd/main.go
    ```
    ```bash
    go build -o build/orchestrator.exe ./orchestrator/cmd/main.go
    ```
    или
    ```bash
    make build
    ```

### Запуск (без Docker):

1.  Проверьте наличие конфигурации, заданный адрес определяется относительно точки выполнения.
    
2.  Запустите сервисы в отдельных терминалах:

    ```bash
    build/agent
    ```
    ```bash
    build/orchestrator
    ```

### Сборка и запуск с помощью Docker:

1.  Клонируйте репозиторий:

    ```bash
    git clone https://github.com/OinkiePie/calc_2
    ```
    ```bash
    cd calc_2
    ```

2.  Соберите Docker-образы для каждого сервиса:
    ```bash
    docker build -t agent:latest -f agent/Dockerfile .
    ```
    ```bash
    docker build -t orchestrator:latest -f orchestrator/Dockerfile .
     ```
    или
    ```bash
    make d-build
    ```
3.  Создайте общую сеть и запустите контейнеры для каждого сервиса:

    ```bash
    docker network create mynet
    ```
    ```bash
    docker run -d --network mynet \
    -p 8080:8080 -p 50051:50051 \
    --name orchestrator \
    -e ORCHESTRATOR_GRPC_ADDR=0.0.0.0 \
    orchestrator:latest
    ```
    ```bash
    docker run --network mynet \
    -e ORCHESTRATOR_ADDR="orchestrator" \
    -e ORCHESTRATOR_GRPC_PORT="50051" \
    agent:latest
    ```

    Для запуска с другим адресом (по умолчанию `127.0.0.1:8081`) используйте (пример для Web сервиса):
    ```bash
    docker run -e ADDR_WEB="0.0.0.0" -e PORT_WEB=8085 -p 8085:8085 web:latest
    ```

### Запуск с помощью Docker Compose (рекомендуется):

1.  Создайте файл `docker-compose.yml` или используйте уже существующий.

2.  Запустите приложение с помощью Docker Compose:

    ```bash
    docker-compose up -d
    ```

В файле `docker-compose.yml` вы можете изменить адреса и порты в блоке `environment`. Учтите что вы задаете их отдельно для каждого сервиса. Не забудьте что для общения сервисов между собой внутри, docker обращается по названию, например `orchestrator:8080` вместо обычного `127.0.0.1:8080`. При желании можете указать индивидуальные файлы конфигурации через `APP_CFG`.

## Использование
Вы можете открыть `orchestrator\internal\handlers\handlers.go` и `orchestrator\internal\router\router.go` чтобы увидеть подробное описание каждого запроса, указанное в комментариях, включая параметры и требования к запросу.


Если вы решили делать запросы внутри docker для этого придется раскомментировать определенную строку в dockerfile сервиса для установки `bash`, а позже внутри него (`docker exec -it <id сервиса> bash`) прописать `apk update; apk add curl` для установки curl.

Не рекомендую использовать стандартный терминал Windows т.к. он не всегда корректно понимает `curl` запросы.

Для всех запросов существует проверка метода. Если вы отправили на адрес запрос с неподходящим методом вернется ошибка 405. У защищенных endpoint'ов вернется ошибка Unauthorized если не указать корректный токен.

### Открытая сторона
#### Для регистрации пользователя используйте следующий запрос `curl`:
```bash
curl --location 'http://localhost:8080/api/register' \
--header 'Content-Type: application/json' \
--data '{
  "login": "login",
  "password": "123456"
}'
```
Ответы:
- 201 Created - при успешной регистрации
- 400 Bad Request - при некорректном теле запроса
```
пустое тело запроса
```
```
некорректный запрос
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 409 Conflict - если пользователь с таким логином уже существует
```
логин {логин} уже существует
```
- 422 Unprocessable Entity - при ошибке парсинга JSON
```
некорректный запрос
```
- 500 Internal Server Error - при внутренних ошибках сервера
```
не удалось хешировать пароль: {ошибка}
```
```
не удалось создать пользователя: {ошибка}
```
#### Для входа в *аккаунт* используйте следующий запрос `curl`:
```bash
curl --location 'http://localhost:8080/api/login' \
--header 'Content-Type: application/json' \
--data '{
  "login": "login",
  "password": "123456"
}'
```
Ответы:
- 200 OK - при успешной аутентификации
```json
{
  "token": "valid.jwt.token"
}
```
- 400 Bad Request - при некорректном теле запроса
```
пустое тело запроса
```
- 401 Unauthorized - при неверных учетных данных
```
не удалось создать сессию: {ошибка}
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 422 Unprocessable Entity - при ошибке парсинга JSON
```
некорректный запрос
```
- 500 Internal Server Error - при внутренних ошибках сервера
```
ошибка при кодировании ответа в JSON
```
```
ошибка при входе: не удалось начать вход пользователя: {ошибка}
```
```
ошибка при входе: не удалось сгенерировать токен: {ошибка}
```
```
ошибка при входе: вход пользователя не удался: {ошибка}
```
### Защищенная
Все запросы на защищенные endpoint'ы проходят через авторизационный миддлвейр, который может отклонить запрос со следующими ошибками:
- 401 Unauthorized
```
Отсутствует заголовок Authorization
```
```
Неверный формат заголовка Authorization
```
```
Пустой ключ авторизации
```
```
Сессия была завершена или истекла
```
```
не удалось получить сессию: {ошибка}
```
#### Для удаления сессии (выхода) используйте запрос `curl` подобный следующему:
```bash
curl --location 'http://localhost:8080/api/p/logout' \
--header 'Authorization: valid.jwt.token'
```
Ответы:
- 200 OK - при успешном завершении сессии
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 500 Internal Server Error - при внутренних ошибках сервера
```
не удалось удалить сессию: {ошибка}
```
#### Для удаления пользователя используйте запрос `curl` подобный следующему:
```bash
curl --location 'http://localhost:8080/api/p/delete' \
--header 'Authorization: Bearer valid.jwt.token' \
--header 'Content-Type: application/json' \
--data '{
  "login": "login",
  "password": "123456"
}'
```
- 200 OK - при успешном удалении
- 400 Bad Request - при некорректном теле запроса
``` 
пустое тело запроса
```
``` 
некорректный запрос
```
- 401 Unauthorized - при неверных учетных данных
```
пользователь не найден
```
```
не удалось получить пользователя: {ошибка}
```
``` 
пароли не совпадают
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 422 Unprocessable Entity - при ошибке парсинга JSON
```
некорректный запрос
```
- 500 Internal Server Error - при внутренних ошибках сервера
```
не удалось удалить пользователя: {ошибка}
```
#### Для создания математического выражения используйте запрос `curl` подобный следующему:
```bash
curl --location 'http://localhost:8080/api/p/calculate' \
--header 'Authorization: Bearer valid.jwt.token' \
--header 'Content-Type: application/json' \
--data '{
  "expression": "1+2*3",
}'
```
- 200 OK - при успешном создании выражения
```json
{
  "id": 1
}
```
- 400 Bad Request - при пустом выражении
```
пустое тело запроса
```
```
выражения обязательно
```
```
минимум два операнда требуются для расчета
```
```
неоткрытая скобка
```
```
незакрытая скобка
```
```
неверный синтаксис
```
```
недостаточно операндов
```
```
недостаточно операндов для унарного минуса
```
```
не удалось преобразовать RPN
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 422 Unprocessable Entity - при ошибке парсинга JSON
```
некорректный запрос
```
- 500 Internal Server Error - при внутренних ошибках сервера
```
не удалось начать добавление выражения: {ошибка}
```
```
не удалось вставить выражение: {ошибка}
```
```
не удалось создать задачу: {ошибка}
```
```
не удалось установить аргументы задачи: {ошибка}
```
```
не удалось установить зависимости задачи: {ошибка}
```
```
не удалось обновить зависимости задачи: {ошибка}
```
```
не удалось обновить id задачи выражения: {ошибка}
```
```
не удалось создать выражение: {ошибка}
```
```
ошибка при кодировании ответа в JSON
```
#### Для получения списка выражений используйте запрос `curl` подобный следующему:
```bash
curl --location 'http://localhost:8080/api/p/expressions' \
--header 'Authorization: Bearer valid.jwt.token'
```
- 200 OK - при успешном получении списка
```json
{
  "expressions": [
    {
      "id": "уникальный ID выражения",
      "status": "статус выражения (pending, processing, completed, error)",
      "expression": "исходное выражение",
      "result": "результат выражения (может отсутствовать, если вычисления не завершены)",
      "error": "ошибка при вычислении (может отсутствовать, если ошибки нет)"
    },
    {
      "id": 1,
      "status": "completed",
      "expression": "1+2*3",
      "result": "7"
    },
    {
      "id": 2,
      "status": "completed",
      "expression": "3/0",
      "error": "деление на ноль"
    }
  ]
}
```
- 404 Not Found если выражения не найдены
```
выражения пользователя №{идентификатор} не найдены
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 500 Internal Server Error - при внутренних ошибках сервера
```
ошибка при кодировании ответа в JSON
```
```
не удалось начать получение выражения: {ошибка}
```
```
не удалось получить выражения: {ошибка}
```
```
не удалось прочитать выражение: {ошибка}
```
```
ошибка при обработке строк: {ошибка}
```
```
не удалось получить задачи: {ошибка}
```
```
не удалось прочитать задачи: {ошибка}
```
```
не удалось получить зависимости задачи: {ошибка}
```
```
не удалось получить аргументы задачи: {ошибка}
```
```
не удалось получить выражение: {ошибка}
```
#### Для получения конкретного выражения по id запрос `curl` подобный следующему:
(на месте `:id` вставьте идентификатор полученный при отправке выражения (`:` оставлять не нужно))
```bash
curl --location 'http://localhost:8080/api/p/expressions/:id' \
--header 'Authorization: Bearer valid.jwt.token'
```
```bash
curl --location 'http://localhost:8080/api/p/expressions/1' \
--header 'Authorization: Bearer valid.jwt.token'
```
- 200 OK - при успешном получении выражения
```json
{
  "id": 1,
  "status": "completed",
  "expression": "1+2*3",
  "result": "7"
}
```
- 400 Bad Request - при некорректном ID выражения
```
не удалось перевести выражение в число
```
- 403 Forbidden - при попытке доступа к чужому выражению
```
невозможно получить выражение другого пользователя
```
- 404 Not Found - если выражение не найдено
```
выражение не найдено
```
- 405 Method Not Allowed - при неправильном методе запроса
```
метод не поддерживается
``` 
- 500 Internal Server Error - при внутренних ошибках сервера
```
не удалось начать отправку выражение: {ошибка}
```
```
не удалось получить выражение: {ошибка}
```
```
ошибка при обработке строк: {ошибка}
```
```
не удалось получить задачи: {ошибка}
```
```
не удалось прочитать задачи: {ошибка}
```
```
не удалось получить зависимости задачи: {ошибка}
```
```
не удалось получить аргументы задачи: {ошибка}
```
```
не удалось отправить выражение: {ошибка}
```
```
ошибка при кодировании ответа в JSON
```

## Тестирование

Проект имеет модульные и интеграционные тесты, проверяющие работоспособность кода.

При выполнении команды не забудьте указать путь к файлу.
```bash
go test .\config
```
Также вы можете протестировать все файлы.
```bash
go test ./...
```

## Логгирование
Логирование происходит через пакет logger, который инициализируется при запуске сервиса. Вы можете изменить его параметры через файл конфигурации. Параметры, которы можно изменить:

*	level `int` - Текущий уровень логирования.

	1. DebugLevel - логирует все сообщения
	2. InfoLevel - логирует информационные сообщения, предупреждения и ошибки.
	3. WarningLevel - логирует предупреждения и ошибки.
	4. ErrorLevel - логирует ошибки.
	5. FatalLevel - логирует ошибки и затем вызывает os.Exit(1).
	6. Disabled - отключает все логирование.

*	timeFormat `string` - Формат для временных меток
*	callDepth `int` - Глубина вызова для определения файла:строки источника
*	disableCall `bool` - Отключить вывод источника.
*	disableTime `bool` - Отключить временные метки в логах.
*	disableColor `bool` - Отключить цветной вывод.
